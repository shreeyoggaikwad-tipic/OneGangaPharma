import {
  users,
  addresses,
  medicines,
  medicineCategories,
  medicineInventory,
  prescriptions,
  cartItems,
  orders,
  orderItems,
  notifications,
  type User,
  type InsertUser,
  type Address,
  type InsertAddress,
  type Medicine,
  type InsertMedicine,
  type MedicineInventory,
  type InsertMedicineInventory,
  type Prescription,
  type InsertPrescription,
  type CartItem,
  type InsertCartItem,
  type Order,
  type InsertOrder,
  type OrderItem,
  type InsertOrderItem,
  type Notification,
  type InsertNotification,
  type MedicineCategory,
} from "@shared/schema";
import { db } from "./db";
import { eq, and, desc, asc, count, sum, sql, gte, lte } from "drizzle-orm";
import bcrypt from "bcrypt";

export interface IStorage {
  // User operations
  getUser(id: number): Promise<User | undefined>;
  getUserByEmail(email: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  updateUser(id: number, user: Partial<InsertUser>): Promise<User>;
  verifyPassword(password: string, hashedPassword: string): Promise<boolean>;

  // Address operations
  getAddressesByUserId(userId: number): Promise<Address[]>;
  createAddress(address: InsertAddress): Promise<Address>;
  updateAddress(id: number, address: Partial<InsertAddress>): Promise<Address>;
  deleteAddress(id: number): Promise<void>;

  // Medicine operations
  getMedicines(): Promise<(Medicine & { category: MedicineCategory; totalStock: number })[]>;
  getMedicineById(id: number): Promise<Medicine | undefined>;
  searchMedicines(query: string): Promise<(Medicine & { category: MedicineCategory; totalStock: number })[]>;
  createMedicine(medicine: InsertMedicine): Promise<Medicine>;
  updateMedicine(id: number, medicine: Partial<InsertMedicine>): Promise<Medicine>;
  deleteMedicine(id: number): Promise<void>;

  // Medicine categories
  getMedicineCategories(): Promise<MedicineCategory[]>;
  createMedicineCategory(name: string, description?: string, isScheduleH?: boolean): Promise<MedicineCategory>;

  // Medicine inventory operations
  getMedicineInventory(medicineId: number): Promise<MedicineInventory[]>;
  createMedicineInventory(inventory: InsertMedicineInventory): Promise<MedicineInventory>;
  updateMedicineInventory(id: number, inventory: Partial<InsertMedicineInventory>): Promise<MedicineInventory>;
  getLowStockMedicines(): Promise<(Medicine & { totalStock: number })[]>;

  // Prescription operations
  getPrescriptionsByUserId(userId: number): Promise<Prescription[]>;
  getPendingPrescriptions(): Promise<(Prescription & { user: User })[]>;
  createPrescription(prescription: InsertPrescription): Promise<Prescription>;
  updatePrescriptionStatus(id: number, status: string, reviewedBy: number, notes?: string): Promise<Prescription>;

  // Cart operations
  getCartItems(userId: number): Promise<(CartItem & { medicine: Medicine })[]>;
  addToCart(cartItem: InsertCartItem): Promise<CartItem>;
  updateCartItem(id: number, quantity: number): Promise<CartItem>;
  removeFromCart(id: number): Promise<void>;
  clearCart(userId: number): Promise<void>;

  // Order operations
  getOrdersByUserId(userId: number): Promise<(Order & { items: (OrderItem & { medicine: Medicine })[] })[]>;
  getAllOrders(): Promise<(Order & { user: User; items: (OrderItem & { medicine: Medicine })[] })[]>;
  createOrder(order: InsertOrder, items: InsertOrderItem[]): Promise<Order>;
  updateOrderStatus(id: number, status: string): Promise<Order>;
  getOrderById(id: number): Promise<(Order & { 
    user: User; 
    items: (OrderItem & { medicine: Medicine })[];
    billingAddress: Address;
    shippingAddress: Address;
    prescription?: Prescription;
  }) | undefined>;

  // Notification operations
  getNotificationsByUserId(userId: number): Promise<Notification[]>;
  createNotification(notification: InsertNotification): Promise<Notification>;
  markNotificationAsRead(id: number): Promise<void>;
  deleteNotification(id: number): Promise<void>;

  // Dashboard stats
  getDashboardStats(): Promise<{
    totalSales: number;
    ordersToday: number;
    lowStockCount: number;
    pendingPrescriptions: number;
  }>;

  // Analytics
  getSalesAnalytics(timePeriod: string): Promise<any[]>;
  getCategoryAnalytics(): Promise<any[]>;

  // Initialize data
  initializeData(): Promise<void>;
}

export class DatabaseStorage implements IStorage {
  async getUser(id: number): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }

  async getUserByEmail(email: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.email, email));
    return user;
  }

  async createUser(user: InsertUser): Promise<User> {
    const hashedPassword = await bcrypt.hash(user.password, 10);
    const [newUser] = await db
      .insert(users)
      .values({ ...user, password: hashedPassword })
      .returning();
    return newUser;
  }

  async updateUser(id: number, user: Partial<InsertUser>): Promise<User> {
    const updateData = { ...user };
    if (updateData.password) {
      updateData.password = await bcrypt.hash(updateData.password, 10);
    }
    const [updatedUser] = await db
      .update(users)
      .set({ ...updateData, updatedAt: new Date() })
      .where(eq(users.id, id))
      .returning();
    return updatedUser;
  }

  async verifyPassword(password: string, hashedPassword: string): Promise<boolean> {
    return bcrypt.compare(password, hashedPassword);
  }

  async getAddressesByUserId(userId: number): Promise<Address[]> {
    return db.select().from(addresses).where(eq(addresses.userId, userId));
  }

  async createAddress(address: InsertAddress): Promise<Address> {
    const [newAddress] = await db.insert(addresses).values(address).returning();
    return newAddress;
  }

  async updateAddress(id: number, address: Partial<InsertAddress>): Promise<Address> {
    const [updatedAddress] = await db
      .update(addresses)
      .set(address)
      .where(eq(addresses.id, id))
      .returning();
    return updatedAddress;
  }

  async deleteAddress(id: number): Promise<void> {
    await db.delete(addresses).where(eq(addresses.id, id));
  }

  async getMedicines(): Promise<(Medicine & { category: MedicineCategory; totalStock: number })[]> {
    return db
      .select({
        id: medicines.id,
        name: medicines.name,
        description: medicines.description,
        dosage: medicines.dosage,
        price: medicines.price,
        categoryId: medicines.categoryId,
        manufacturer: medicines.manufacturer,
        requiresPrescription: medicines.requiresPrescription,
        isActive: medicines.isActive,
        createdAt: medicines.createdAt,
        updatedAt: medicines.updatedAt,
        category: medicineCategories,
        totalStock: sql<number>`COALESCE(SUM(${medicineInventory.quantity}), 0)`,
      })
      .from(medicines)
      .leftJoin(medicineCategories, eq(medicines.categoryId, medicineCategories.id))
      .leftJoin(medicineInventory, eq(medicines.id, medicineInventory.medicineId))
      .where(eq(medicines.isActive, true))
      .groupBy(medicines.id, medicineCategories.id)
      .orderBy(asc(medicines.name)) as any;
  }

  async getMedicineById(id: number): Promise<Medicine | undefined> {
    const [medicine] = await db.select().from(medicines).where(eq(medicines.id, id));
    return medicine;
  }

  async searchMedicines(query: string): Promise<(Medicine & { category: MedicineCategory; totalStock: number })[]> {
    return db
      .select({
        id: medicines.id,
        name: medicines.name,
        description: medicines.description,
        dosage: medicines.dosage,
        price: medicines.price,
        categoryId: medicines.categoryId,
        manufacturer: medicines.manufacturer,
        requiresPrescription: medicines.requiresPrescription,
        isActive: medicines.isActive,
        createdAt: medicines.createdAt,
        updatedAt: medicines.updatedAt,
        category: medicineCategories,
        totalStock: sql<number>`COALESCE(SUM(${medicineInventory.quantity}), 0)`,
      })
      .from(medicines)
      .leftJoin(medicineCategories, eq(medicines.categoryId, medicineCategories.id))
      .leftJoin(medicineInventory, eq(medicines.id, medicineInventory.medicineId))
      .where(
        and(
          eq(medicines.isActive, true),
          sql`LOWER(${medicines.name}) LIKE LOWER(${'%' + query + '%'})`
        )
      )
      .groupBy(medicines.id, medicineCategories.id)
      .orderBy(asc(medicines.name)) as any;
  }

  async createMedicine(medicine: InsertMedicine): Promise<Medicine> {
    const [newMedicine] = await db.insert(medicines).values(medicine).returning();
    return newMedicine;
  }

  async updateMedicine(id: number, medicine: Partial<InsertMedicine>): Promise<Medicine> {
    const [updatedMedicine] = await db
      .update(medicines)
      .set({ ...medicine, updatedAt: new Date() })
      .where(eq(medicines.id, id))
      .returning();
    return updatedMedicine;
  }

  async deleteMedicine(id: number): Promise<void> {
    await db.update(medicines).set({ isActive: false }).where(eq(medicines.id, id));
  }

  async getMedicineCategories(): Promise<MedicineCategory[]> {
    return db.select().from(medicineCategories).orderBy(asc(medicineCategories.name));
  }

  async createMedicineCategory(name: string, description?: string, isScheduleH?: boolean): Promise<MedicineCategory> {
    const [category] = await db
      .insert(medicineCategories)
      .values({ name, description, isScheduleH: isScheduleH || false })
      .returning();
    return category;
  }

  async getMedicineInventory(medicineId: number): Promise<MedicineInventory[]> {
    return db
      .select()
      .from(medicineInventory)
      .where(eq(medicineInventory.medicineId, medicineId))
      .orderBy(asc(medicineInventory.expiryDate));
  }

  async createMedicineInventory(inventory: InsertMedicineInventory): Promise<MedicineInventory> {
    const [newInventory] = await db.insert(medicineInventory).values(inventory).returning();
    return newInventory;
  }

  async updateMedicineInventory(id: number, inventory: Partial<InsertMedicineInventory>): Promise<MedicineInventory> {
    const [updatedInventory] = await db
      .update(medicineInventory)
      .set({ ...inventory, updatedAt: new Date() })
      .where(eq(medicineInventory.id, id))
      .returning();
    return updatedInventory;
  }

  async getLowStockMedicines(): Promise<(Medicine & { totalStock: number })[]> {
    return db
      .select({
        id: medicines.id,
        name: medicines.name,
        description: medicines.description,
        dosage: medicines.dosage,
        price: medicines.price,
        categoryId: medicines.categoryId,
        manufacturer: medicines.manufacturer,
        requiresPrescription: medicines.requiresPrescription,
        isActive: medicines.isActive,
        createdAt: medicines.createdAt,
        updatedAt: medicines.updatedAt,
        totalStock: sql<number>`COALESCE(SUM(${medicineInventory.quantity}), 0)`,
      })
      .from(medicines)
      .leftJoin(medicineInventory, eq(medicines.id, medicineInventory.medicineId))
      .where(eq(medicines.isActive, true))
      .groupBy(medicines.id)
      .having(sql`COALESCE(SUM(${medicineInventory.quantity}), 0) < 20`)
      .orderBy(sql`COALESCE(SUM(${medicineInventory.quantity}), 0)`) as any;
  }

  async getPrescriptionsByUserId(userId: number): Promise<Prescription[]> {
    return db
      .select()
      .from(prescriptions)
      .where(eq(prescriptions.userId, userId))
      .orderBy(desc(prescriptions.uploadedAt));
  }

  async getPendingPrescriptions(): Promise<(Prescription & { user: User })[]> {
    return db
      .select({
        id: prescriptions.id,
        userId: prescriptions.userId,
        fileName: prescriptions.fileName,
        filePath: prescriptions.filePath,
        status: prescriptions.status,
        reviewedBy: prescriptions.reviewedBy,
        reviewedAt: prescriptions.reviewedAt,
        reviewNotes: prescriptions.reviewNotes,
        uploadedAt: prescriptions.uploadedAt,
        user: users,
      })
      .from(prescriptions)
      .leftJoin(users, eq(prescriptions.userId, users.id))
      .where(eq(prescriptions.status, "pending"))
      .orderBy(desc(prescriptions.uploadedAt)) as any;
  }

  async createPrescription(prescription: InsertPrescription): Promise<Prescription> {
    const [newPrescription] = await db.insert(prescriptions).values(prescription).returning();
    return newPrescription;
  }

  async updatePrescriptionStatus(id: number, status: string, reviewedBy: number, notes?: string): Promise<Prescription> {
    const [updatedPrescription] = await db
      .update(prescriptions)
      .set({
        status,
        reviewedBy,
        reviewedAt: new Date(),
        reviewNotes: notes,
      })
      .where(eq(prescriptions.id, id))
      .returning();
    return updatedPrescription;
  }

  async getCartItems(userId: number): Promise<(CartItem & { medicine: Medicine })[]> {
    return db
      .select({
        id: cartItems.id,
        userId: cartItems.userId,
        medicineId: cartItems.medicineId,
        quantity: cartItems.quantity,
        addedAt: cartItems.addedAt,
        medicine: medicines,
      })
      .from(cartItems)
      .leftJoin(medicines, eq(cartItems.medicineId, medicines.id))
      .where(eq(cartItems.userId, userId)) as any;
  }

  async addToCart(cartItem: InsertCartItem): Promise<CartItem> {
    // Check if item already exists in cart
    const [existingItem] = await db
      .select()
      .from(cartItems)
      .where(
        and(
          eq(cartItems.userId, cartItem.userId),
          eq(cartItems.medicineId, cartItem.medicineId)
        )
      );

    if (existingItem) {
      // Update quantity
      const [updatedItem] = await db
        .update(cartItems)
        .set({ quantity: existingItem.quantity + cartItem.quantity })
        .where(eq(cartItems.id, existingItem.id))
        .returning();
      return updatedItem;
    } else {
      // Add new item
      const [newItem] = await db.insert(cartItems).values(cartItem).returning();
      return newItem;
    }
  }

  async updateCartItem(id: number, quantity: number): Promise<CartItem> {
    const [updatedItem] = await db
      .update(cartItems)
      .set({ quantity })
      .where(eq(cartItems.id, id))
      .returning();
    return updatedItem;
  }

  async removeFromCart(id: number): Promise<void> {
    await db.delete(cartItems).where(eq(cartItems.id, id));
  }

  async clearCart(userId: number): Promise<void> {
    await db.delete(cartItems).where(eq(cartItems.userId, userId));
  }

  async getOrdersByUserId(userId: number): Promise<(Order & { items: (OrderItem & { medicine: Medicine })[] })[]> {
    const ordersData = await db
      .select({
        order: orders,
        item: orderItems,
        medicine: medicines,
      })
      .from(orders)
      .leftJoin(orderItems, eq(orders.id, orderItems.orderId))
      .leftJoin(medicines, eq(orderItems.medicineId, medicines.id))
      .where(eq(orders.userId, userId))
      .orderBy(desc(orders.placedAt));

    // Group by order
    const orderMap = new Map();
    ordersData.forEach(({ order, item, medicine }) => {
      if (!orderMap.has(order.id)) {
        orderMap.set(order.id, { ...order, items: [] });
      }
      if (item && medicine) {
        orderMap.get(order.id).items.push({ ...item, medicine });
      }
    });

    return Array.from(orderMap.values());
  }

  async getAllOrders(): Promise<(Order & { user: User; items: (OrderItem & { medicine: Medicine })[] })[]> {
    const ordersData = await db
      .select({
        order: orders,
        user: users,
        item: orderItems,
        medicine: medicines,
      })
      .from(orders)
      .leftJoin(users, eq(orders.userId, users.id))
      .leftJoin(orderItems, eq(orders.id, orderItems.orderId))
      .leftJoin(medicines, eq(orderItems.medicineId, medicines.id))
      .orderBy(desc(orders.placedAt));

    // Group by order
    const orderMap = new Map();
    ordersData.forEach(({ order, user, item, medicine }) => {
      if (!orderMap.has(order.id)) {
        orderMap.set(order.id, { ...order, user, items: [] });
      }
      if (item && medicine) {
        orderMap.get(order.id).items.push({ ...item, medicine });
      }
    });

    return Array.from(orderMap.values());
  }

  async createOrder(order: InsertOrder, items: InsertOrderItem[]): Promise<Order> {
    // Generate shorter order number (SMD + 8 digits)
    const timestamp = Date.now().toString();
    const orderNumber = `SMD${timestamp.slice(-8)}`;
    
    const [newOrder] = await db
      .insert(orders)
      .values({ ...order, orderNumber })
      .returning();

    // Add order items
    const orderItemsWithOrderId = items.map(item => ({ ...item, orderId: newOrder.id }));
    await db.insert(orderItems).values(orderItemsWithOrderId);

    return newOrder;
  }

  async updateOrderStatus(id: number, status: string): Promise<Order> {
    const updateData: any = { status };
    if (status === "delivered") {
      updateData.deliveredAt = new Date();
    }

    const [updatedOrder] = await db
      .update(orders)
      .set(updateData)
      .where(eq(orders.id, id))
      .returning();
    return updatedOrder;
  }

  async getOrderById(id: number): Promise<(Order & { 
    user: User; 
    items: (OrderItem & { medicine: Medicine })[];
    billingAddress: Address;
    shippingAddress: Address;
    prescription?: Prescription;
  }) | undefined> {
    const orderData = await db
      .select({
        order: orders,
        user: users,
        item: orderItems,
        medicine: medicines,
        billingAddress: sql`billing_addr`,
        shippingAddress: sql`shipping_addr`,
        prescription: prescriptions,
      })
      .from(orders)
      .leftJoin(users, eq(orders.userId, users.id))
      .leftJoin(orderItems, eq(orders.id, orderItems.orderId))
      .leftJoin(medicines, eq(orderItems.medicineId, medicines.id))
      .leftJoin(sql`${addresses} AS billing_addr`, sql`billing_addr.id = ${orders.billingAddressId}`)
      .leftJoin(sql`${addresses} AS shipping_addr`, sql`shipping_addr.id = ${orders.shippingAddressId}`)
      .leftJoin(prescriptions, eq(orders.prescriptionId, prescriptions.id))
      .where(eq(orders.id, id));

    if (orderData.length === 0) return undefined;

    const { order, user, billingAddress, shippingAddress, prescription } = orderData[0];
    const items = orderData
      .filter(({ item, medicine }) => item && medicine)
      .map(({ item, medicine }) => ({ ...item, medicine }));

    return {
      ...order,
      user,
      items,
      billingAddress: billingAddress as Address,
      shippingAddress: shippingAddress as Address,
      prescription: prescription || undefined,
    } as any;
  }

  async getNotificationsByUserId(userId: number): Promise<Notification[]> {
    return db
      .select()
      .from(notifications)
      .where(eq(notifications.userId, userId))
      .orderBy(desc(notifications.createdAt));
  }

  async createNotification(notification: InsertNotification): Promise<Notification> {
    const [newNotification] = await db.insert(notifications).values(notification).returning();
    return newNotification;
  }

  async markNotificationAsRead(id: number): Promise<void> {
    await db.update(notifications).set({ isRead: true }).where(eq(notifications.id, id));
  }

  async deleteNotification(id: number): Promise<void> {
    await db.delete(notifications).where(eq(notifications.id, id));
  }

  async getDashboardStats(): Promise<{
    totalSales: number;
    ordersToday: number;
    lowStockCount: number;
    pendingPrescriptions: number;
  }> {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const [salesResult] = await db
      .select({ totalSales: sum(orders.totalAmount) })
      .from(orders)
      .where(eq(orders.status, "delivered"));

    const [ordersTodayResult] = await db
      .select({ count: count() })
      .from(orders)
      .where(sql`DATE(${orders.placedAt}) = DATE(${today})`);

    const [lowStockResult] = await db
      .select({ count: count() })
      .from(medicines)
      .leftJoin(medicineInventory, eq(medicines.id, medicineInventory.medicineId))
      .where(eq(medicines.isActive, true))
      .groupBy(medicines.id)
      .having(sql`COALESCE(SUM(${medicineInventory.quantity}), 0) < 20`);

    const [pendingPrescriptionsResult] = await db
      .select({ count: count() })
      .from(prescriptions)
      .where(eq(prescriptions.status, "pending"));

    return {
      totalSales: Number(salesResult?.totalSales || 0),
      ordersToday: ordersTodayResult?.count || 0,
      lowStockCount: lowStockResult?.count || 0,
      pendingPrescriptions: pendingPrescriptionsResult?.count || 0,
    };
  }

  async getSalesAnalytics(timePeriod: string): Promise<any[]> {
    // Get all orders for analytics
    const allOrders = await db.select().from(orders);
    
    const today = new Date();
    const data = [];
    
    switch (timePeriod) {
      case "weekly":
        for (let i = 6; i >= 0; i--) {
          const date = new Date(today);
          date.setDate(date.getDate() - i);
          const dayStart = new Date(date);
          dayStart.setHours(0, 0, 0, 0);
          const dayEnd = new Date(date);
          dayEnd.setHours(23, 59, 59, 999);
          
          const dayOrders = allOrders.filter(order => {
            if (!order.placedAt) return false;
            const orderDate = new Date(order.placedAt);
            return orderDate >= dayStart && orderDate <= dayEnd;
          });
          
          const deliveredOrders = dayOrders.filter(order => order.status === "delivered");
          const totalSales = deliveredOrders.reduce((sum, order) => sum + Number(order.totalAmount), 0);
          
          data.push({
            date: date.toISOString().split('T')[0],
            sales: totalSales,
            orders: dayOrders.length,
            label: date.toLocaleDateString('en-IN', { weekday: 'short', day: 'numeric' })
          });
        }
        break;
      
      default:
        const deliveredOrders = allOrders.filter(order => order.status === "delivered");
        const totalSales = deliveredOrders.reduce((sum, order) => sum + Number(order.totalAmount), 0);
        
        data.push({
          date: today.toISOString().split('T')[0],
          sales: totalSales,
          orders: allOrders.length,
          label: "Total"
        });
    }
    
    return data;
  }

  async getCategoryAnalytics(): Promise<any[]> {
    const categoryStats = await db
      .select({
        name: medicineCategories.name,
        count: count(medicines.id)
      })
      .from(medicineCategories)
      .leftJoin(medicines, eq(medicineCategories.id, medicines.categoryId))
      .where(eq(medicines.isActive, true))
      .groupBy(medicineCategories.id, medicineCategories.name);

    const colors = ["#0088FE", "#00C49F", "#FFBB28", "#FF8042", "#8884D8", "#82CA9D"];
    
    return categoryStats.map((category, index) => ({
      name: category.name,
      value: category.count,
      color: colors[index % colors.length]
    }));
  }

  async initializeData(): Promise<void> {
    // Check if data already exists
    const existingUsers = await db.select().from(users).limit(1);
    if (existingUsers.length > 0) return;

    // Create admin user
    const adminUser = await this.createUser({
      email: "admin@test.com",
      password: "admin123",
      role: "admin",
      firstName: "Admin",
      lastName: "User",
      phone: "9876543210",
    });

    // Create customer user
    const customerUser = await this.createUser({
      email: "customer@test.com",
      password: "password123",
      role: "customer",
      firstName: "John",
      lastName: "Doe",
      phone: "9876543211",
      gender: "male",
      dateOfBirth: "1990-01-01",
    });

    // Create medicine categories
    const generalCategory = await this.createMedicineCategory("General", "General medicines", false);
    const scheduleHCategory = await this.createMedicineCategory("Schedule H", "Prescription required medicines", true);
    const ayurvedicCategory = await this.createMedicineCategory("Ayurvedic", "Traditional Indian medicines", false);

    // Create sample medicines
    const medicines = [
      {
        name: "Paracetamol 500mg",
        description: "Pain relief and fever reducer",
        dosage: "500mg",
        price: "45.50",
        categoryId: scheduleHCategory.id,
        manufacturer: "Cipla Ltd",
        requiresPrescription: true,
      },
      {
        name: "Vitamin D3 Tablets",
        description: "Essential vitamin supplement",
        dosage: "60000 IU",
        price: "125.00",
        categoryId: generalCategory.id,
        manufacturer: "Sun Pharma",
        requiresPrescription: false,
      },
      {
        name: "Cough Syrup",
        description: "Cough relief formula",
        dosage: "100ml",
        price: "89.00",
        categoryId: generalCategory.id,
        manufacturer: "Dabur",
        requiresPrescription: false,
      },
      {
        name: "Antibiotic Tablets",
        description: "Bacterial infection treatment",
        dosage: "250mg",
        price: "185.50",
        categoryId: scheduleHCategory.id,
        manufacturer: "Dr. Reddy's",
        requiresPrescription: true,
      },
      {
        name: "Ashwagandha Capsules",
        description: "Stress relief and immunity booster",
        dosage: "300mg",
        price: "299.00",
        categoryId: ayurvedicCategory.id,
        manufacturer: "Himalaya",
        requiresPrescription: false,
      },
    ];

    for (const medicine of medicines) {
      const newMedicine = await this.createMedicine(medicine);
      
      // Add inventory
      await this.createMedicineInventory({
        medicineId: newMedicine.id,
        batchNumber: `BATCH${Math.random().toString(36).substr(2, 6).toUpperCase()}`,
        expiryDate: "2025-12-31",
        quantity: Math.floor(Math.random() * 100) + 50,
      });
    }

    // Create sample address for customer
    await this.createAddress({
      userId: customerUser.id,
      type: "billing",
      fullName: "John Doe",
      phone: "9876543211",
      addressLine1: "123 Main Street",
      addressLine2: "Apartment 4B",
      city: "Mumbai",
      state: "Maharashtra",
      postalCode: "400001",
      isDefault: true,
    });

    await this.createAddress({
      userId: customerUser.id,
      type: "shipping",
      fullName: "John Doe",
      phone: "9876543211",
      addressLine1: "123 Main Street",
      addressLine2: "Apartment 4B",
      city: "Mumbai",
      state: "Maharashtra",
      postalCode: "400001",
      isDefault: true,
    });
  }
}

export const storage = new DatabaseStorage();
